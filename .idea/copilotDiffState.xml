<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/src/main/java/service/FileProcessingService.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/service/FileProcessingService.java" />
              <option name="originalContent" value="package service;&#10;&#10;import model.ExternalGeneralResult;&#10;import model.ExternalSpecificModuleResult;&#10;import model.ExternalSpecificResult;&#10;import model.InternalResult;&#10;import model.Ciudad;&#10;import model.Departamento;&#10;import model.Modulo;&#10;&#10;import repository.ExternalGeneralResultRepository;&#10;import repository.ExternalSpecificModuleResultRepository;&#10;import repository.ExternalSpecificResultRepository;&#10;import repository.InternalResultRepository;&#10;import repository.CiudadRepository;&#10;import repository.DepartamentoRepository;&#10;import repository.ModuloRepository;&#10;&#10;import org.springframework.stereotype.Service;&#10;import org.springframework.web.multipart.MultipartFile;&#10;import org.springframework.transaction.annotation.Transactional;&#10;&#10;import java.io.BufferedReader;&#10;import java.io.InputStreamReader;&#10;import java.nio.charset.StandardCharsets;&#10;import java.time.OffsetDateTime;&#10;import java.util.*;&#10;&#10;@Service&#10;public class FileProcessingService {&#10;&#10;    private final ExternalGeneralResultRepository generalRepo;&#10;    private final ExternalSpecificResultRepository specificRepo;&#10;    private final InternalResultRepository internalRepo;&#10;    private final CiudadRepository ciudadRepo;&#10;    private final DepartamentoRepository departamentoRepo;&#10;    private final ModuloRepository moduloRepo;&#10;    private final ExternalSpecificModuleResultRepository moduleResultRepo;&#10;&#10;&#10;    private static final int BATCH_SIZE_GENERAL = 2000;&#10;    private static final int BATCH_SIZE_SPEC = 500;&#10;    private static final int BATCH_SIZE_INTERNAL = 1000;&#10;&#10;    public FileProcessingService(ExternalGeneralResultRepository generalRepo,&#10;                                 ExternalSpecificResultRepository specificRepo,&#10;                                 InternalResultRepository internalRepo,&#10;                                 CiudadRepository ciudadRepo,&#10;                                 DepartamentoRepository departamentoRepo,&#10;                                 ModuloRepository moduloRepo,&#10;                                 ExternalSpecificModuleResultRepository moduleResultRepo) {&#10;        this.generalRepo = generalRepo;&#10;        this.specificRepo = specificRepo;&#10;        this.internalRepo = internalRepo;&#10;        this.ciudadRepo = ciudadRepo;&#10;        this.departamentoRepo = departamentoRepo;&#10;        this.moduloRepo = moduloRepo;&#10;        this.moduleResultRepo = moduleResultRepo;&#10;    }&#10;&#10;    private String[] splitLine(String line) {&#10;        return line.split(&quot;[;\t,]&quot;, -1);&#10;    }&#10;&#10;    private Integer parseInteger(String s) {&#10;        if (s == null) return null;&#10;        s = s.trim();&#10;        if (s.isEmpty()) return null;&#10;        try {&#10;            s = s.replace(&quot;,&quot;, &quot;&quot;);&#10;            return Integer.valueOf(s);&#10;        } catch (Exception e) {&#10;            return null;&#10;        }&#10;    }&#10;&#10;    private boolean looksLikeHeader(String headerLine, String[] requiredTokens) {&#10;        if (headerLine == null) return false;&#10;        String low = headerLine.toLowerCase();&#10;        for (String t : requiredTokens) if (!low.contains(t)) return false;&#10;        return true;&#10;    }&#10;&#10;    @Transactional&#10;    public List&lt;ExternalGeneralResult&gt; parseAndSaveGeneral(MultipartFile file) throws Exception {&#10;        List&lt;ExternalGeneralResult&gt; savedAll = new ArrayList&lt;&gt;();&#10;        List&lt;ExternalGeneralResult&gt; buffer = new ArrayList&lt;&gt;(BATCH_SIZE_GENERAL);&#10;&#10;        try (BufferedReader br = new BufferedReader(new InputStreamReader(file.getInputStream(), StandardCharsets.UTF_8))) {&#10;            String firstLine = br.readLine();&#10;            if (firstLine == null) return savedAll;&#10;&#10;            boolean hasHeader = looksLikeHeader(firstLine, new String[]{&quot;periodo&quot;,&quot;est_consecutivo&quot;});&#10;            String[] headers = hasHeader ? splitLine(firstLine) : null;&#10;            Map&lt;String,Integer&gt; idx = new HashMap&lt;&gt;();&#10;            if (headers != null) for (int i=0;i&lt;headers.length;i++) idx.put(headers[i].trim().toLowerCase(), i);&#10;&#10;            String line = hasHeader ? br.readLine() : firstLine;&#10;            while (line != null) {&#10;                String[] cols = splitLine(line);&#10;                ExternalGeneralResult r = new ExternalGeneralResult();&#10;                // normalizar periodo para almacenar solo el aÃ±o (ej. 20121 -&gt; 2012)&#10;                r.setPeriodo(parsePeriodoAsYear(get(cols, idx, &quot;periodo&quot;)));&#10;                r.setEstConsecutivo(get(cols, idx, &quot;est_consecutivo&quot;));&#10;                r.setEstuDiscapacidad(get(cols, idx, &quot;estu_discapacidad&quot;));&#10;                r.setEstuInstDepartamento(get(cols, idx, &quot;estu_inst_departamento&quot;));&#10;                r.setEstuInstMunicipio(get(cols, idx, &quot;estu_inst_municipio&quot;));&#10;                r.setEstuNucleoPregrado(get(cols, idx, &quot;estu_nucleo_pregrado&quot;));&#10;                r.setEstuPrgmAcademico(get(cols, idx, &quot;estu_prgm_academico&quot;));&#10;                r.setEstuSniesPrgmacademico(get(cols, idx, &quot;estu_snies_prgmacademico&quot;));&#10;                r.setInstCodInstitucion(parseInteger(get(cols, idx, &quot;inst_cod_institucion&quot;)));&#10;                r.setInstNombreInstitucion(get(cols, idx, &quot;inst_nombre_institucion&quot;));&#10;&#10;                r.setModCompetenCiudadaPnal(parseInteger(get(cols, idx, &quot;mod_competen_ciudada_pnal&quot;)));&#10;                r.setModCompetenCiudadaPnbc(parseInteger(get(cols, idx, &quot;mod_competen_ciudada_pnbc&quot;)));&#10;                r.setModCompetenCiudadaPunt(parseInteger(get(cols, idx, &quot;mod_competen_ciudada_punt&quot;)));&#10;                r.setModComuniEscritaPnal(parseInteger(get(cols, idx, &quot;mod_comuni_escrita_pnal&quot;)));&#10;                r.setModComuniEscritaPnbc(parseInteger(get(cols, idx, &quot;mod_comuni_escrita_pnbc&quot;)));&#10;                r.setModComuniEscritaPunt(parseInteger(get(cols, idx, &quot;mod_comuni_escrita_punt&quot;)));&#10;                r.setModInglesPnal(parseInteger(get(cols, idx, &quot;mod_ingles_pnal&quot;)));&#10;                r.setModInglesPnbc(parseInteger(get(cols, idx, &quot;mod_ingles_pnbc&quot;)));&#10;                r.setModInglesPunt(parseInteger(get(cols, idx, &quot;mod_ingles_punt&quot;)));&#10;                r.setModLecturaCriticaPnal(parseInteger(get(cols, idx, &quot;mod_lectura_critica_pnal&quot;)));&#10;                r.setModLecturaCriticaPnbc(parseInteger(get(cols, idx, &quot;mod_lectura_critica_pnbc&quot;)));&#10;                r.setModLecturaCriticaPunt(parseInteger(get(cols, idx, &quot;mod_lectura_critica_punt&quot;)));&#10;                r.setModRazonaCuantitativoPnal(parseInteger(get(cols, idx, &quot;mod_razona_cuantitativo_pnal&quot;)));&#10;                r.setModRazonaCuantitativoPnbc(parseInteger(get(cols, idx, &quot;mod_razona_cuantitativo_pnbc&quot;)));&#10;                r.setModRazonaCuantitatPunt(parseInteger(get(cols, idx, &quot;mod_razona_cuantitat_punt&quot;)));&#10;&#10;                r.setPercentilGlobal(parseInteger(get(cols, idx, &quot;percentil_global&quot;)));&#10;                r.setPercentilNbc(parseInteger(get(cols, idx, &quot;percentil_nbc&quot;)));&#10;                r.setPuntGlobal(parseInteger(get(cols, idx, &quot;punt_global&quot;)));&#10;&#10;                r.setCreatedAt(OffsetDateTime.now());&#10;                buffer.add(r);&#10;&#10;                if (buffer.size() &gt;= BATCH_SIZE_GENERAL) {&#10;                    List&lt;ExternalGeneralResult&gt; saved = generalRepo.saveAll(new ArrayList&lt;&gt;(buffer));&#10;                    savedAll.addAll(saved);&#10;                    buffer.clear();&#10;                }&#10;                line = br.readLine();&#10;            }&#10;&#10;            if (!buffer.isEmpty()) {&#10;                List&lt;ExternalGeneralResult&gt; saved = generalRepo.saveAll(buffer);&#10;                savedAll.addAll(saved);&#10;                buffer.clear();&#10;            }&#10;        }&#10;        return savedAll;&#10;    }&#10;&#10;    @Transactional&#10;    public List&lt;ExternalSpecificResult&gt; parseAndSaveSpecifics(MultipartFile file, Integer periodo) throws Exception {&#10;        List&lt;ExternalSpecificResult&gt; savedAll = new ArrayList&lt;&gt;();&#10;        List&lt;ExternalSpecificResult&gt; buffer = new ArrayList&lt;&gt;(BATCH_SIZE_SPEC);&#10;&#10;        try (BufferedReader br = new BufferedReader(new InputStreamReader(file.getInputStream(), StandardCharsets.UTF_8))) {&#10;            String firstLine = br.readLine();&#10;            if (firstLine == null) return savedAll;&#10;&#10;            boolean hasHeader = looksLikeHeader(firstLine, new String[]{&quot;estu_consecutivo&quot;,&quot;result_nombreprueba&quot;});&#10;            String[] headers = hasHeader ? splitLine(firstLine) : null;&#10;            Map&lt;String,Integer&gt; idx = new HashMap&lt;&gt;();&#10;            if (headers != null) for (int i=0;i&lt;headers.length;i++) idx.put(headers[i].trim().toLowerCase(), i);&#10;&#10;            String line = hasHeader ? br.readLine() : firstLine;&#10;            while (line != null) {&#10;                String[] cols = splitLine(line);&#10;&#10;                ExternalSpecificResult r = new ExternalSpecificResult();&#10;                // normalizamos el periodo recibido (si viene 20121 -&gt; 2012)&#10;                r.setPeriodo(normalizePeriodo(periodo));&#10;                String estConsec = get(cols, idx, &quot;estu_consecutivo&quot;);&#10;                r.setEstuConsecutivo(estConsec);&#10;                String prueba = get(cols, idx, &quot;result_nombreprueba&quot;);&#10;                r.setResultNombrePrueba(prueba);&#10;                r.setResultPuntaje(parseInteger(get(cols, idx, &quot;result_puntaje&quot;)));&#10;                r.setPercentilNacional(parseInteger(get(cols, idx, &quot;percentil_nacional&quot;)));&#10;                r.setPercentilNbc(parseInteger(get(cols, idx, &quot;percentil_nbc&quot;)));&#10;&#10;                Integer moduloId = resolveOrCreateModuloId(prueba);&#10;                r.setModuloId(moduloId);&#10;&#10;                if (r.getPeriodo() != null &amp;&amp; estConsec != null) {&#10;                    Optional&lt;ExternalGeneralResult&gt; og = generalRepo.findFirstByPeriodoAndEstConsecutivo(r.getPeriodo(), estConsec);&#10;                    og.ifPresent(g -&gt; r.setExternaId(g.getId()));&#10;                }&#10;&#10;                buffer.add(r);&#10;&#10;                if (buffer.size() &gt;= BATCH_SIZE_SPEC) {&#10;                    List&lt;ExternalSpecificResult&gt; saved = specificRepo.saveAll(new ArrayList&lt;&gt;(buffer));&#10;                    savedAll.addAll(saved);&#10;                    buffer.clear();&#10;                }&#10;                line = br.readLine();&#10;            }&#10;&#10;            if (!buffer.isEmpty()) {&#10;                List&lt;ExternalSpecificResult&gt; saved = specificRepo.saveAll(buffer);&#10;                savedAll.addAll(saved);&#10;                buffer.clear();&#10;            }&#10;        }&#10;        return savedAll;&#10;    }&#10;&#10;    @Transactional&#10;    public List&lt;InternalResult&gt; parseAndSaveInternal(MultipartFile file) throws Exception {&#10;        List&lt;InternalResult&gt; savedAll = new ArrayList&lt;&gt;();&#10;        List&lt;InternalResult&gt; buffer = new ArrayList&lt;&gt;(BATCH_SIZE_INTERNAL);&#10;        List&lt;TempModuleResult&gt; moduleTempBuffer = new ArrayList&lt;&gt;();&#10;&#10;        try (BufferedReader br = new BufferedReader(new InputStreamReader(file.getInputStream(), StandardCharsets.UTF_8))) {&#10;            String firstLine = br.readLine();&#10;            if (firstLine == null) return savedAll;&#10;&#10;            boolean hasHeader = looksLikeHeader(firstLine, new String[]{&quot;tipo de documento&quot;,&quot;documento&quot;});&#10;            String[] headers = hasHeader ? splitLine(firstLine) : null;&#10;            Map&lt;String,Integer&gt; idx = new HashMap&lt;&gt;();&#10;            if (headers != null) for (int i=0;i&lt;headers.length;i++) idx.put(headers[i].trim().toLowerCase(), i);&#10;&#10;            String line = hasHeader ? br.readLine() : firstLine;&#10;            while (line != null) {&#10;                String[] cols = splitLine(line);&#10;&#10;                InternalResult r = new InternalResult();&#10;                r.setTipoDocumento(get(cols, idx, &quot;tipo de documento&quot;));&#10;                r.setDocumento(get(cols, idx, &quot;documento&quot;));&#10;                r.setNombre(get(cols, idx, &quot;nombre&quot;));&#10;                String numeroRegistro = get(cols, idx, &quot;nÃºmero de registro&quot;);&#10;                r.setNumeroRegistro(numeroRegistro);&#10;                r.setTipoEvaluado(get(cols, idx, &quot;tipo de evaluado&quot;));&#10;                r.setSniesPrograma(get(cols, idx, &quot;snies programa acadÃ©mico&quot;));&#10;                r.setPrograma(get(cols, idx, &quot;programa&quot;));&#10;&#10;                String rawCiudad = get(cols, idx, &quot;ciudad&quot;);&#10;                String rawDepartamento = get(cols, idx, &quot;departamento&quot;);&#10;                Integer ciudadId = resolveCiudadId(rawCiudad);&#10;                Integer departamentoId = resolveDepartamentoId(rawDepartamento);&#10;                r.setCiudadId(ciudadId);&#10;                r.setDepartamentoId(departamentoId);&#10;&#10;                r.setGrupoReferencia(get(cols, idx, &quot;grupo de referencia&quot;));&#10;                r.setPuntajeGlobal(parseInteger(get(cols, idx, &quot;puntaje global&quot;)));&#10;                r.setPercentilNacionalGlobal(parseInteger(get(cols, idx, &quot;percentil nacional global&quot;)));&#10;                r.setPercentilGrupoReferencia(parseInteger(get(cols, idx, &quot;percentil grupo de referencia&quot;)));&#10;                r.setCreatedAt(OffsetDateTime.now());&#10;&#10;                int bufferIndex = buffer.size();&#10;                buffer.add(r);&#10;&#10;                String moduloNombre = get(cols, idx, &quot;mÃ³dulo&quot;);&#10;                if (moduloNombre == null) moduloNombre = get(cols, idx, &quot;modulo&quot;);&#10;                Integer puntajeModulo = parseInteger(get(cols, idx, &quot;puntaje mÃ³dulo&quot;));&#10;                Integer percentilNacModulo = parseInteger(get(cols, idx, &quot;percentil nacional modulo&quot;));&#10;                Integer percentilGrupoModulo = parseInteger(get(cols, idx, &quot;percentil grupo de referencia modulo&quot;));&#10;&#10;                if (moduloNombre != null || puntajeModulo != null || percentilNacModulo != null || percentilGrupoModulo != null) {&#10;                    TempModuleResult tmp = new TempModuleResult();&#10;                    tmp.internalIndex = bufferIndex;&#10;                    tmp.moduloNombre = moduloNombre;&#10;                    tmp.puntaje = puntajeModulo;&#10;                    tmp.percentilNacional = percentilNacModulo;&#10;                    tmp.percentilGrupoReferencia = percentilGrupoModulo;&#10;                    moduleTempBuffer.add(tmp);&#10;                }&#10;&#10;                if (buffer.size() &gt;= BATCH_SIZE_INTERNAL) {&#10;                    List&lt;InternalResult&gt; saved = internalRepo.saveAll(new ArrayList&lt;&gt;(buffer));&#10;                    // link module results by preserving order&#10;                    linkAndSaveModuleResults(saved, moduleTempBuffer);&#10;                    savedAll.addAll(saved);&#10;                    buffer.clear();&#10;                    moduleTempBuffer.clear();&#10;                }&#10;&#10;                line = br.readLine();&#10;            }&#10;&#10;            if (!buffer.isEmpty()) {&#10;                List&lt;InternalResult&gt; saved = internalRepo.saveAll(buffer);&#10;                linkAndSaveModuleResults(saved, moduleTempBuffer);&#10;                savedAll.addAll(saved);&#10;                buffer.clear();&#10;                moduleTempBuffer.clear();&#10;            }&#10;        }&#10;        return savedAll;&#10;    }&#10;&#10;    private String get(String[] cols, Map&lt;String,Integer&gt; idx, String key) {&#10;        Integer i = idx.get(key.toLowerCase());&#10;        if (i == null || i &lt; 0 || i &gt;= cols.length) {&#10;            for (Map.Entry&lt;String,Integer&gt; e : idx.entrySet()) {&#10;                String k = e.getKey().replace(&quot; &quot;, &quot;&quot;).replace(&quot;Ã­&quot;,&quot;i&quot;).replace(&quot;Ã³&quot;,&quot;o&quot;);&#10;                String kk = key.toLowerCase().replace(&quot; &quot;, &quot;&quot;).replace(&quot;Ã­&quot;,&quot;i&quot;).replace(&quot;Ã³&quot;,&quot;o&quot;);&#10;                if (k.equals(kk)) return cols[e.getValue()].trim().isEmpty() ? null : cols[e.getValue()].trim();&#10;            }&#10;            return null;&#10;        }&#10;        String v = cols[i].trim();&#10;        return v.isEmpty() ? null : v;&#10;    }&#10;&#10;    private Integer resolveCiudadId(String raw) {&#10;        if (raw == null) return null;&#10;        Integer asInt = parseInteger(raw);&#10;        if (asInt != null) return asInt;&#10;        String name = raw.trim();&#10;        Optional&lt;Ciudad&gt; oc = ciudadRepo.findFirstByNombreIgnoreCase(name);&#10;        if (oc.isPresent()) return oc.get().getIdCiudad();&#10;        String n2 = name.replace(&quot;Ã­&quot;,&quot;i&quot;).replace(&quot;Ã³&quot;,&quot;o&quot;).trim();&#10;        oc = ciudadRepo.findFirstByNombreIgnoreCase(n2);&#10;        if (oc.isPresent()) return oc.get().getIdCiudad();&#10;        Ciudad nueva = new Ciudad();&#10;        nueva.setNombre(name);&#10;        Ciudad saved = ciudadRepo.save(nueva);&#10;        return saved.getIdCiudad();&#10;    }&#10;&#10;    private Integer resolveDepartamentoId(String raw) {&#10;        if (raw == null) return null;&#10;        Integer asInt = parseInteger(raw);&#10;        if (asInt != null) return asInt;&#10;        String name = raw.trim();&#10;        Optional&lt;Departamento&gt; od = departamentoRepo.findFirstByNombreIgnoreCase(name);&#10;        if (od.isPresent()) return od.get().getIdDepartamento().intValue();&#10;        String n2 = name.replace(&quot;Ã­&quot;,&quot;i&quot;).replace(&quot;Ã³&quot;,&quot;o&quot;).trim();&#10;        od = departamentoRepo.findFirstByNombreIgnoreCase(n2);&#10;        if (od.isPresent()) return od.get().getIdDepartamento().intValue();&#10;        Departamento nuevo = new Departamento();&#10;        nuevo.setNombre(name);&#10;        Departamento saved = departamentoRepo.save(nuevo);&#10;        return Integer.valueOf(saved.getIdDepartamento());&#10;    }&#10;&#10;    private Integer resolveOrCreateModuloId(String nombrePrueba) {&#10;        if (nombrePrueba == null) return null;&#10;        String normalized = nombrePrueba.trim();&#10;        Optional&lt;Modulo&gt; om = moduloRepo.findFirstByNombreIgnoreCase(normalized);&#10;        if (om.isPresent()) return om.get().getIdModulo();&#10;        Modulo nuevoModulo = new Modulo();&#10;        nuevoModulo.setNombre(normalized);&#10;        Modulo savedModulo = moduloRepo.save(nuevoModulo);&#10;        return savedModulo.getIdModulo();&#10;    }&#10;&#10;    // Normaliza el periodo para almacenar solo el aÃ±o.&#10;    // Ejemplos: 20121 -&gt; 2012 (divide por 10 si el valor tiene mÃ¡s de 4 dÃ­gitos),&#10;    // 2020 -&gt; 2020 (ya solo aÃ±o)&#10;    private Integer normalizePeriodo(Integer periodo) {&#10;        if (periodo == null) return null;&#10;        if (Math.abs(periodo) &gt; 9999) {&#10;            return periodo / 10;&#10;        }&#10;        return periodo;&#10;    }&#10;&#10;    private Integer parsePeriodoAsYear(String raw) {&#10;        Integer p = parseInteger(raw);&#10;        return normalizePeriodo(p);&#10;    }&#10;&#10;    private void linkAndSaveModuleResults(List&lt;InternalResult&gt; savedInternals, List&lt;TempModuleResult&gt; tempModules) {&#10;        List&lt;ExternalSpecificModuleResult&gt; toSave = new ArrayList&lt;&gt;();&#10;        for (TempModuleResult t : tempModules) {&#10;            if (t.internalIndex &gt;= 0 &amp;&amp; t.internalIndex &lt; savedInternals.size()) {&#10;                InternalResult related = savedInternals.get(t.internalIndex);&#10;                if (related != null) {&#10;                    ExternalSpecificModuleResult rm = new ExternalSpecificModuleResult();&#10;                    rm.setInternoId(related.getId());&#10;                    Integer modId = resolveOrCreateModuloId(t.moduloNombre);&#10;                    rm.setModuloId(modId);&#10;                    rm.setPuntaje(t.puntaje);&#10;                    rm.setPercentilNacional(t.percentilNacional);&#10;                    rm.setPercentilGrupoReferencia(t.percentilGrupoReferencia);&#10;                    toSave.add(rm);&#10;                }&#10;            }&#10;        }&#10;        if (!toSave.isEmpty()) moduleResultRepo.saveAll(toSave);&#10;    }&#10;&#10;    private static class TempModuleResult {&#10;        int internalIndex = -1;&#10;        String moduloNombre;&#10;        Integer puntaje;&#10;        Integer percentilNacional;&#10;        Integer percentilGrupoReferencia;&#10;    }&#10;&#10;    public boolean existsGeneralPeriod(Integer periodo) {&#10;        // normalizamos periodo a aÃ±o antes de consultar&#10;        return generalRepo.existsByPeriodo(normalizePeriodo(periodo));&#10;    }&#10;&#10;}&#10;" />
              <option name="updatedContent" value="package service;&#10;&#10;import model.ExternalGeneralResult;&#10;import model.ExternalSpecificModuleResult;&#10;import model.ExternalSpecificResult;&#10;import model.InternalResult;&#10;import model.Ciudad;&#10;import model.Departamento;&#10;import model.Modulo;&#10;&#10;import repository.ExternalGeneralResultRepository;&#10;import repository.ExternalSpecificModuleResultRepository;&#10;import repository.ExternalSpecificResultRepository;&#10;import repository.InternalResultRepository;&#10;import repository.CiudadRepository;&#10;import repository.DepartamentoRepository;&#10;import repository.ModuloRepository;&#10;&#10;import org.springframework.stereotype.Service;&#10;import org.springframework.web.multipart.MultipartFile;&#10;import org.springframework.transaction.annotation.Transactional;&#10;&#10;import java.io.BufferedReader;&#10;import java.io.InputStreamReader;&#10;import java.nio.charset.StandardCharsets;&#10;import java.time.OffsetDateTime;&#10;import java.util.*;&#10;&#10;@Service&#10;public class FileProcessingService {&#10;&#10;    private final ExternalGeneralResultRepository generalRepo;&#10;    private final ExternalSpecificResultRepository specificRepo;&#10;    private final InternalResultRepository internalRepo;&#10;    private final CiudadRepository ciudadRepo;&#10;    private final DepartamentoRepository departamentoRepo;&#10;    private final ModuloRepository moduloRepo;&#10;    private final ExternalSpecificModuleResultRepository moduleResultRepo;&#10;&#10;&#10;    private static final int BATCH_SIZE_GENERAL = 2000;&#10;    private static final int BATCH_SIZE_SPEC = 500;&#10;    private static final int BATCH_SIZE_INTERNAL = 1000;&#10;&#10;    public FileProcessingService(ExternalGeneralResultRepository generalRepo,&#10;                                 ExternalSpecificResultRepository specificRepo,&#10;                                 InternalResultRepository internalRepo,&#10;                                 CiudadRepository ciudadRepo,&#10;                                 DepartamentoRepository departamentoRepo,&#10;                                 ModuloRepository moduloRepo,&#10;                                 ExternalSpecificModuleResultRepository moduleResultRepo) {&#10;        this.generalRepo = generalRepo;&#10;        this.specificRepo = specificRepo;&#10;        this.internalRepo = internalRepo;&#10;        this.ciudadRepo = ciudadRepo;&#10;        this.departamentoRepo = departamentoRepo;&#10;        this.moduloRepo = moduloRepo;&#10;        this.moduleResultRepo = moduleResultRepo;&#10;    }&#10;&#10;    private String[] splitLine(String line) {&#10;        return line.split(&quot;[;\t,]&quot;, -1);&#10;    }&#10;&#10;    private Integer parseInteger(String s) {&#10;        if (s == null) return null;&#10;        s = s.trim();&#10;        if (s.isEmpty()) return null;&#10;        try {&#10;            s = s.replace(&quot;,&quot;, &quot;&quot;);&#10;            return Integer.valueOf(s);&#10;        } catch (Exception e) {&#10;            return null;&#10;        }&#10;    }&#10;&#10;    private boolean looksLikeHeader(String headerLine, String[] requiredTokens) {&#10;        if (headerLine == null) return false;&#10;        String low = headerLine.toLowerCase();&#10;        for (String t : requiredTokens) if (!low.contains(t)) return false;&#10;        return true;&#10;    }&#10;&#10;    @Transactional&#10;    public List&lt;ExternalGeneralResult&gt; parseAndSaveGeneral(MultipartFile file) throws Exception {&#10;        List&lt;ExternalGeneralResult&gt; savedAll = new ArrayList&lt;&gt;();&#10;        List&lt;ExternalGeneralResult&gt; buffer = new ArrayList&lt;&gt;(BATCH_SIZE_GENERAL);&#10;&#10;        try (BufferedReader br = new BufferedReader(new InputStreamReader(file.getInputStream(), StandardCharsets.UTF_8))) {&#10;            String firstLine = br.readLine();&#10;            if (firstLine == null) return savedAll;&#10;&#10;            boolean hasHeader = looksLikeHeader(firstLine, new String[]{&quot;periodo&quot;,&quot;est_consecutivo&quot;});&#10;            String[] headers = hasHeader ? splitLine(firstLine) : null;&#10;            // Requerimos encabezado en archivos generales para poder extraer el campo 'periodo'.&#10;            if (!hasHeader) {&#10;                throw new IllegalArgumentException(&quot;El archivo general debe incluir encabezado con las columnas 'periodo' y 'est_consecutivo'. AsegÃºrese de subir el archivo correcto (separador ';') y que la primera lÃ­nea contenga esos nombres de columna.&quot;);&#10;            }&#10;            Map&lt;String,Integer&gt; idx = new HashMap&lt;&gt;();&#10;            if (headers != null) for (int i=0;i&lt;headers.length;i++) idx.put(headers[i].trim().toLowerCase(), i);&#10;&#10;            String line = hasHeader ? br.readLine() : firstLine;&#10;            while (line != null) {&#10;                String[] cols = splitLine(line);&#10;                ExternalGeneralResult r = new ExternalGeneralResult();&#10;                // normalizar periodo para almacenar solo el aÃ±o (ej. 20121 -&gt; 2012)&#10;                Integer periodoParsed = parsePeriodoAsYear(get(cols, idx, &quot;periodo&quot;));&#10;                if (periodoParsed == null) {&#10;                    throw new IllegalArgumentException(&quot;No se pudo determinar el 'periodo' en la lÃ­nea: '&quot; + line + &quot;'. AsegÃºrese que la columna 'periodo' tenga valores y que el separador sea ';' o tab.&quot;);&#10;                }&#10;                r.setPeriodo(periodoParsed);&#10;                r.setEstConsecutivo(get(cols, idx, &quot;est_consecutivo&quot;));&#10;                r.setEstuDiscapacidad(get(cols, idx, &quot;estu_discapacidad&quot;));&#10;                r.setEstuInstDepartamento(get(cols, idx, &quot;estu_inst_departamento&quot;));&#10;                r.setEstuInstMunicipio(get(cols, idx, &quot;estu_inst_municipio&quot;));&#10;                r.setEstuNucleoPregrado(get(cols, idx, &quot;estu_nucleo_pregrado&quot;));&#10;                r.setEstuPrgmAcademico(get(cols, idx, &quot;estu_prgm_academico&quot;));&#10;                r.setEstuSniesPrgmacademico(get(cols, idx, &quot;estu_snies_prgmacademico&quot;));&#10;                r.setInstCodInstitucion(parseInteger(get(cols, idx, &quot;inst_cod_institucion&quot;)));&#10;                r.setInstNombreInstitucion(get(cols, idx, &quot;inst_nombre_institucion&quot;));&#10;&#10;                r.setModCompetenCiudadaPnal(parseInteger(get(cols, idx, &quot;mod_competen_ciudada_pnal&quot;)));&#10;                r.setModCompetenCiudadaPnbc(parseInteger(get(cols, idx, &quot;mod_competen_ciudada_pnbc&quot;)));&#10;                r.setModCompetenCiudadaPunt(parseInteger(get(cols, idx, &quot;mod_competen_ciudada_punt&quot;)));&#10;                r.setModComuniEscritaPnal(parseInteger(get(cols, idx, &quot;mod_comuni_escrita_pnal&quot;)));&#10;                r.setModComuniEscritaPnbc(parseInteger(get(cols, idx, &quot;mod_comuni_escrita_pnbc&quot;)));&#10;                r.setModComuniEscritaPunt(parseInteger(get(cols, idx, &quot;mod_comuni_escrita_punt&quot;)));&#10;                r.setModInglesPnal(parseInteger(get(cols, idx, &quot;mod_ingles_pnal&quot;)));&#10;                r.setModInglesPnbc(parseInteger(get(cols, idx, &quot;mod_ingles_pnbc&quot;)));&#10;                r.setModInglesPunt(parseInteger(get(cols, idx, &quot;mod_ingles_punt&quot;)));&#10;                r.setModLecturaCriticaPnal(parseInteger(get(cols, idx, &quot;mod_lectura_critica_pnal&quot;)));&#10;                r.setModLecturaCriticaPnbc(parseInteger(get(cols, idx, &quot;mod_lectura_critica_pnbc&quot;)));&#10;                r.setModLecturaCriticaPunt(parseInteger(get(cols, idx, &quot;mod_lectura_critica_punt&quot;)));&#10;                r.setModRazonaCuantitativoPnal(parseInteger(get(cols, idx, &quot;mod_razona_cuantitativo_pnal&quot;)));&#10;                r.setModRazonaCuantitativoPnbc(parseInteger(get(cols, idx, &quot;mod_razona_cuantitativo_pnbc&quot;)));&#10;                r.setModRazonaCuantitatPunt(parseInteger(get(cols, idx, &quot;mod_razona_cuantitat_punt&quot;)));&#10;&#10;                r.setPercentilGlobal(parseInteger(get(cols, idx, &quot;percentil_global&quot;)));&#10;                r.setPercentilNbc(parseInteger(get(cols, idx, &quot;percentil_nbc&quot;)));&#10;                r.setPuntGlobal(parseInteger(get(cols, idx, &quot;punt_global&quot;)));&#10;&#10;                r.setCreatedAt(OffsetDateTime.now());&#10;                buffer.add(r);&#10;&#10;                if (buffer.size() &gt;= BATCH_SIZE_GENERAL) {&#10;                    List&lt;ExternalGeneralResult&gt; saved = generalRepo.saveAll(new ArrayList&lt;&gt;(buffer));&#10;                    savedAll.addAll(saved);&#10;                    buffer.clear();&#10;                }&#10;                line = br.readLine();&#10;            }&#10;&#10;            if (!buffer.isEmpty()) {&#10;                List&lt;ExternalGeneralResult&gt; saved = generalRepo.saveAll(buffer);&#10;                savedAll.addAll(saved);&#10;                buffer.clear();&#10;            }&#10;        }&#10;        return savedAll;&#10;    }&#10;&#10;    @Transactional&#10;    public List&lt;ExternalSpecificResult&gt; parseAndSaveSpecifics(MultipartFile file, Integer periodo) throws Exception {&#10;        List&lt;ExternalSpecificResult&gt; savedAll = new ArrayList&lt;&gt;();&#10;        List&lt;ExternalSpecificResult&gt; buffer = new ArrayList&lt;&gt;(BATCH_SIZE_SPEC);&#10;&#10;        try (BufferedReader br = new BufferedReader(new InputStreamReader(file.getInputStream(), StandardCharsets.UTF_8))) {&#10;            String firstLine = br.readLine();&#10;            if (firstLine == null) return savedAll;&#10;&#10;            boolean hasHeader = looksLikeHeader(firstLine, new String[]{&quot;estu_consecutivo&quot;,&quot;result_nombreprueba&quot;});&#10;            String[] headers = hasHeader ? splitLine(firstLine) : null;&#10;            Map&lt;String,Integer&gt; idx = new HashMap&lt;&gt;();&#10;            if (headers != null) for (int i=0;i&lt;headers.length;i++) idx.put(headers[i].trim().toLowerCase(), i);&#10;&#10;            String line = hasHeader ? br.readLine() : firstLine;&#10;            while (line != null) {&#10;                String[] cols = splitLine(line);&#10;&#10;                ExternalSpecificResult r = new ExternalSpecificResult();&#10;                // normalizamos el periodo recibido (si viene 20121 -&gt; 2012)&#10;                r.setPeriodo(normalizePeriodo(periodo));&#10;                String estConsec = get(cols, idx, &quot;estu_consecutivo&quot;);&#10;                r.setEstuConsecutivo(estConsec);&#10;                String prueba = get(cols, idx, &quot;result_nombreprueba&quot;);&#10;                r.setResultNombrePrueba(prueba);&#10;                r.setResultPuntaje(parseInteger(get(cols, idx, &quot;result_puntaje&quot;)));&#10;                r.setPercentilNacional(parseInteger(get(cols, idx, &quot;percentil_nacional&quot;)));&#10;                r.setPercentilNbc(parseInteger(get(cols, idx, &quot;percentil_nbc&quot;)));&#10;&#10;                Integer moduloId = resolveOrCreateModuloId(prueba);&#10;                r.setModuloId(moduloId);&#10;&#10;                if (r.getPeriodo() != null &amp;&amp; estConsec != null) {&#10;                    Optional&lt;ExternalGeneralResult&gt; og = generalRepo.findFirstByPeriodoAndEstConsecutivo(r.getPeriodo(), estConsec);&#10;                    og.ifPresent(g -&gt; r.setExternaId(g.getId()));&#10;                }&#10;&#10;                buffer.add(r);&#10;&#10;                if (buffer.size() &gt;= BATCH_SIZE_SPEC) {&#10;                    List&lt;ExternalSpecificResult&gt; saved = specificRepo.saveAll(new ArrayList&lt;&gt;(buffer));&#10;                    savedAll.addAll(saved);&#10;                    buffer.clear();&#10;                }&#10;                line = br.readLine();&#10;            }&#10;&#10;            if (!buffer.isEmpty()) {&#10;                List&lt;ExternalSpecificResult&gt; saved = specificRepo.saveAll(buffer);&#10;                savedAll.addAll(saved);&#10;                buffer.clear();&#10;            }&#10;        }&#10;        return savedAll;&#10;    }&#10;&#10;    @Transactional&#10;    public List&lt;InternalResult&gt; parseAndSaveInternal(MultipartFile file) throws Exception {&#10;        List&lt;InternalResult&gt; savedAll = new ArrayList&lt;&gt;();&#10;        List&lt;InternalResult&gt; buffer = new ArrayList&lt;&gt;(BATCH_SIZE_INTERNAL);&#10;        List&lt;TempModuleResult&gt; moduleTempBuffer = new ArrayList&lt;&gt;();&#10;&#10;        try (BufferedReader br = new BufferedReader(new InputStreamReader(file.getInputStream(), StandardCharsets.UTF_8))) {&#10;            String firstLine = br.readLine();&#10;            if (firstLine == null) return savedAll;&#10;&#10;            boolean hasHeader = looksLikeHeader(firstLine, new String[]{&quot;tipo de documento&quot;,&quot;documento&quot;});&#10;            String[] headers = hasHeader ? splitLine(firstLine) : null;&#10;            Map&lt;String,Integer&gt; idx = new HashMap&lt;&gt;();&#10;            if (headers != null) for (int i=0;i&lt;headers.length;i++) idx.put(headers[i].trim().toLowerCase(), i);&#10;&#10;            String line = hasHeader ? br.readLine() : firstLine;&#10;            while (line != null) {&#10;                String[] cols = splitLine(line);&#10;&#10;                InternalResult r = new InternalResult();&#10;                r.setTipoDocumento(get(cols, idx, &quot;tipo de documento&quot;));&#10;                r.setDocumento(get(cols, idx, &quot;documento&quot;));&#10;                r.setNombre(get(cols, idx, &quot;nombre&quot;));&#10;                String numeroRegistro = get(cols, idx, &quot;nÃºmero de registro&quot;);&#10;                r.setNumeroRegistro(numeroRegistro);&#10;                r.setTipoEvaluado(get(cols, idx, &quot;tipo de evaluado&quot;));&#10;                r.setSniesPrograma(get(cols, idx, &quot;snies programa acadÃ©mico&quot;));&#10;                r.setPrograma(get(cols, idx, &quot;programa&quot;));&#10;&#10;                String rawCiudad = get(cols, idx, &quot;ciudad&quot;);&#10;                String rawDepartamento = get(cols, idx, &quot;departamento&quot;);&#10;                Integer ciudadId = resolveCiudadId(rawCiudad);&#10;                Integer departamentoId = resolveDepartamentoId(rawDepartamento);&#10;                r.setCiudadId(ciudadId);&#10;                r.setDepartamentoId(departamentoId);&#10;&#10;                r.setGrupoReferencia(get(cols, idx, &quot;grupo de referencia&quot;));&#10;                r.setPuntajeGlobal(parseInteger(get(cols, idx, &quot;puntaje global&quot;)));&#10;                r.setPercentilNacionalGlobal(parseInteger(get(cols, idx, &quot;percentil nacional global&quot;)));&#10;                r.setPercentilGrupoReferencia(parseInteger(get(cols, idx, &quot;percentil grupo de referencia&quot;)));&#10;                r.setCreatedAt(OffsetDateTime.now());&#10;&#10;                int bufferIndex = buffer.size();&#10;                buffer.add(r);&#10;&#10;                String moduloNombre = get(cols, idx, &quot;mÃ³dulo&quot;);&#10;                if (moduloNombre == null) moduloNombre = get(cols, idx, &quot;modulo&quot;);&#10;                Integer puntajeModulo = parseInteger(get(cols, idx, &quot;puntaje mÃ³dulo&quot;));&#10;                Integer percentilNacModulo = parseInteger(get(cols, idx, &quot;percentil nacional modulo&quot;));&#10;                Integer percentilGrupoModulo = parseInteger(get(cols, idx, &quot;percentil grupo de referencia modulo&quot;));&#10;&#10;                if (moduloNombre != null || puntajeModulo != null || percentilNacModulo != null || percentilGrupoModulo != null) {&#10;                    TempModuleResult tmp = new TempModuleResult();&#10;                    tmp.internalIndex = bufferIndex;&#10;                    tmp.moduloNombre = moduloNombre;&#10;                    tmp.puntaje = puntajeModulo;&#10;                    tmp.percentilNacional = percentilNacModulo;&#10;                    tmp.percentilGrupoReferencia = percentilGrupoModulo;&#10;                    moduleTempBuffer.add(tmp);&#10;                }&#10;&#10;                if (buffer.size() &gt;= BATCH_SIZE_INTERNAL) {&#10;                    List&lt;InternalResult&gt; saved = internalRepo.saveAll(new ArrayList&lt;&gt;(buffer));&#10;                    // link module results by preserving order&#10;                    linkAndSaveModuleResults(saved, moduleTempBuffer);&#10;                    savedAll.addAll(saved);&#10;                    buffer.clear();&#10;                    moduleTempBuffer.clear();&#10;                }&#10;&#10;                line = br.readLine();&#10;            }&#10;&#10;            if (!buffer.isEmpty()) {&#10;                List&lt;InternalResult&gt; saved = internalRepo.saveAll(buffer);&#10;                linkAndSaveModuleResults(saved, moduleTempBuffer);&#10;                savedAll.addAll(saved);&#10;                buffer.clear();&#10;                moduleTempBuffer.clear();&#10;            }&#10;        }&#10;        return savedAll;&#10;    }&#10;&#10;    private String get(String[] cols, Map&lt;String,Integer&gt; idx, String key) {&#10;        Integer i = idx.get(key.toLowerCase());&#10;        if (i == null || i &lt; 0 || i &gt;= cols.length) {&#10;            for (Map.Entry&lt;String,Integer&gt; e : idx.entrySet()) {&#10;                String k = e.getKey().replace(&quot; &quot;, &quot;&quot;).replace(&quot;Ã­&quot;,&quot;i&quot;).replace(&quot;Ã³&quot;,&quot;o&quot;);&#10;                String kk = key.toLowerCase().replace(&quot; &quot;, &quot;&quot;).replace(&quot;Ã­&quot;,&quot;i&quot;).replace(&quot;Ã³&quot;,&quot;o&quot;);&#10;                if (k.equals(kk)) return cols[e.getValue()].trim().isEmpty() ? null : cols[e.getValue()].trim();&#10;            }&#10;            return null;&#10;        }&#10;        String v = cols[i].trim();&#10;        return v.isEmpty() ? null : v;&#10;    }&#10;&#10;    private Integer resolveCiudadId(String raw) {&#10;        if (raw == null) return null;&#10;        Integer asInt = parseInteger(raw);&#10;        if (asInt != null) return asInt;&#10;        String name = raw.trim();&#10;        Optional&lt;Ciudad&gt; oc = ciudadRepo.findFirstByNombreIgnoreCase(name);&#10;        if (oc.isPresent()) return oc.get().getIdCiudad();&#10;        String n2 = name.replace(&quot;Ã­&quot;,&quot;i&quot;).replace(&quot;Ã³&quot;,&quot;o&quot;).trim();&#10;        oc = ciudadRepo.findFirstByNombreIgnoreCase(n2);&#10;        if (oc.isPresent()) return oc.get().getIdCiudad();&#10;        Ciudad nueva = new Ciudad();&#10;        nueva.setNombre(name);&#10;        Ciudad saved = ciudadRepo.save(nueva);&#10;        return saved.getIdCiudad();&#10;    }&#10;&#10;    private Integer resolveDepartamentoId(String raw) {&#10;        if (raw == null) return null;&#10;        Integer asInt = parseInteger(raw);&#10;        if (asInt != null) return asInt;&#10;        String name = raw.trim();&#10;        Optional&lt;Departamento&gt; od = departamentoRepo.findFirstByNombreIgnoreCase(name);&#10;        if (od.isPresent()) return od.get().getIdDepartamento().intValue();&#10;        String n2 = name.replace(&quot;Ã­&quot;,&quot;i&quot;).replace(&quot;Ã³&quot;,&quot;o&quot;).trim();&#10;        od = departamentoRepo.findFirstByNombreIgnoreCase(n2);&#10;        if (od.isPresent()) return od.get().getIdDepartamento().intValue();&#10;        Departamento nuevo = new Departamento();&#10;        nuevo.setNombre(name);&#10;        Departamento saved = departamentoRepo.save(nuevo);&#10;        return Integer.valueOf(saved.getIdDepartamento());&#10;    }&#10;&#10;    private Integer resolveOrCreateModuloId(String nombrePrueba) {&#10;        if (nombrePrueba == null) return null;&#10;        String normalized = nombrePrueba.trim();&#10;        Optional&lt;Modulo&gt; om = moduloRepo.findFirstByNombreIgnoreCase(normalized);&#10;        if (om.isPresent()) return om.get().getIdModulo();&#10;        Modulo nuevoModulo = new Modulo();&#10;        nuevoModulo.setNombre(normalized);&#10;        Modulo savedModulo = moduloRepo.save(nuevoModulo);&#10;        return savedModulo.getIdModulo();&#10;    }&#10;&#10;    // Normaliza el periodo para almacenar solo el aÃ±o.&#10;    // Ejemplos: 20121 -&gt; 2012 (divide por 10 si el valor tiene mÃ¡s de 4 dÃ­gitos),&#10;    // 2020 -&gt; 2020 (ya solo aÃ±o)&#10;    private Integer normalizePeriodo(Integer periodo) {&#10;        if (periodo == null) return null;&#10;        if (Math.abs(periodo) &gt; 9999) {&#10;            return periodo / 10;&#10;        }&#10;        return periodo;&#10;    }&#10;&#10;    private Integer parsePeriodoAsYear(String raw) {&#10;        Integer p = parseInteger(raw);&#10;        return normalizePeriodo(p);&#10;    }&#10;&#10;    private void linkAndSaveModuleResults(List&lt;InternalResult&gt; savedInternals, List&lt;TempModuleResult&gt; tempModules) {&#10;        List&lt;ExternalSpecificModuleResult&gt; toSave = new ArrayList&lt;&gt;();&#10;        for (TempModuleResult t : tempModules) {&#10;            if (t.internalIndex &gt;= 0 &amp;&amp; t.internalIndex &lt; savedInternals.size()) {&#10;                InternalResult related = savedInternals.get(t.internalIndex);&#10;                if (related != null) {&#10;                    ExternalSpecificModuleResult rm = new ExternalSpecificModuleResult();&#10;                    rm.setInternoId(related.getId());&#10;                    Integer modId = resolveOrCreateModuloId(t.moduloNombre);&#10;                    rm.setModuloId(modId);&#10;                    rm.setPuntaje(t.puntaje);&#10;                    rm.setPercentilNacional(t.percentilNacional);&#10;                    rm.setPercentilGrupoReferencia(t.percentilGrupoReferencia);&#10;                    toSave.add(rm);&#10;                }&#10;            }&#10;        }&#10;        if (!toSave.isEmpty()) moduleResultRepo.saveAll(toSave);&#10;    }&#10;&#10;    private static class TempModuleResult {&#10;        int internalIndex = -1;&#10;        String moduloNombre;&#10;        Integer puntaje;&#10;        Integer percentilNacional;&#10;        Integer percentilGrupoReferencia;&#10;    }&#10;&#10;    public boolean existsGeneralPeriod(Integer periodo) {&#10;        // normalizamos periodo a aÃ±o antes de consultar&#10;        return generalRepo.existsByPeriodo(normalizePeriodo(periodo));&#10;    }&#10;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>